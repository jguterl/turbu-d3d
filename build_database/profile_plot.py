# TEMPORARY FILE: EDITS WILL NOT BE SAVED!
# This file was generated by omfit_classes.utils_base.function_to_tree()

defaultVars(t=None, dt=25.0, position_type='psi', params=['temp', 'density'], systems='all', unit_convert=True, fig=None, axs=None)
self = 

"""
Plots profiles of physics quantities vs. spatial position for a selected time window

:param t: float
    Center of time window in ms

:param dt: float
    Half-width of time window in ms. All data between t-dt and t+dt will be plotted.

:param position_type: string
    Name of X coordinate. Valid options: 'R', 'Z', 'PSI'

:param params: list of strings
    List physics quantities to plot. Valid options are temp, density, and press

:param systems: list of strings or 'all'
    List subsystems to include in the plot. Choose all to use self.subsystems.

:param unit_convert: bool
    Convert units from eV to keV, etc. so most quantities will be closer to order 1 in the core.

:param fig: Figure instance
    Plot will be drawn using existing figure instance if one is provided. Otherwise, a new figure will be made.

:param axs: 1D array of Axes instances matching length of params.
    Plots will be drawn using existing Axes instances if they are provided. Otherwise, new axes will be added to
    fig.

:return: Figure instance, 1D array of Axes instances
"""
from matplotlib import pyplot

if systems == 'all':
    systems = self.subsystems

names = {
    'press': '$p_e$ (kPa)' if unit_convert else '$p_e$ (Pa)',
    'density': '$n_e$ (10$^{19}$/m$^{3}$)' if unit_convert else '$n_e$ (m$^{-3}$)',
    'temp': '$T_e$ (keV)' if unit_convert else '$T_e$ (eV)',
}
multipliers = {'press': 1e-3 if unit_convert else 1, 'density': 1e-19 if unit_convert else 1, 'temp': 1e-3 if unit_convert else 1}

if fig is None:
    fig = pyplot.figure()
if axs is None:
    axs = self.setup_axes(fig, len(tolist(params)), sharex='all')
axs = np.atleast_1d(axs)
axs[0].set_title('Thomson scattering')
for ax in axs[:-1]:
    ax.tick_params(labelbottom=False)

if t is None:
    self.printdq('No profile time provided to OMFITthomson profile_plot. Picking one arbitrarily...', topic='OMFITthomson')
    # Pick a time automatically based on where data are available
    okay1 = self['filtered'][systems[0]]['filters']['okay']
    # Sum okay flag along channels
    okay2 = np.sum(okay1, axis=0)
    # Find times when most channels are available (avail. ch. count >= 90th percentile)
    okay3 = okay2 >= np.percentile(okay2, 90)
    # Take the mean of times when most channels are available and use that to plot
    t = np.mean(self['filtered'][systems[0]]['time'][okay3])
    # Is this a good idea? Well, if you don't like it, try passing in a time!
    printw(
        'No time provided to OMFITthomson.profile_plot. t = {} was chosen; it is the average of times with '
        'high channel availability on the first listed subsystem ({}).'.format(t, systems[0])
    )

for sub in systems:
    wt = (self['filtered'][sub]['time'] >= (t - dt)) & (self['filtered'][sub]['time'] <= (t + dt))
    okay = self['filtered'][sub]['filters']['okay'][:, wt]
    if position_type in ['z', 'Z']:
        x = self['filtered'][sub]['z'][:, np.newaxis] + 0 * wt
        axs[-1].set_xlabel('$Z$ (m)')
    elif position_type in ['r', 'R']:
        x = self['filtered'][sub]['r'][:, np.newaxis] + 0 * wt
        axs[-1].set_xlabel('$R$ (m)')
    else:
        x = self['filtered'][sub]['psin_TS'][:, wt]
        axs[-1].set_xlabel(r'$\psi_N$')

    for i, param in enumerate(tolist(params)):
        axs[i].set_ylabel(names[param])
        y = self['filtered'][sub][param][:, wt] * multipliers[param]
        try:
            ye = self['filtered'][sub][param + '_e'][:, wt] * multipliers[param]
        except KeyError:
            ye = y * 0
        axs[i].errorbar(x[okay], y[okay], ye[okay], label=sub, linestyle='', marker='_')

for ax in axs:
    ax.legend(loc=0)

try:
    # Getting at OMFIT plot utilities when doing stand-alone command-line stuff can be a burden
    cornernote(shot=self.shot, device=self.device, time=r'{}$\pm${}'.format(t, dt))
except NameError:
    fig.text(
        0.99,
        0.01,
        r'{}#{} {}$\pm${} ms'.format(self.device, self.shot, t, dt),
        fontsize=10,
        ha='right',
        transform=pyplot.gcf().transFigure,
    )