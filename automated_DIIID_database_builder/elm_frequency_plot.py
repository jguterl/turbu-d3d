# TEMPORARY FILE: EDITS WILL NOT BE SAVED!
# This file was generated by omfit_classes.utils_base.function_to_tree()

defaultVars(time_range=None, time_range_for_mean=None, overlay=False, fig=None, axs=None, quiet=False, plotkw={})
self = 

"""
Plots calculated ELM frequency

:param time_range: two element iterable with numbers
    The plot will initially zoom to this time range (ms).

:param time_range_for_mean: two element numeric, True, or False/None
    - True: time_range will be used to define the interval, then the mean ELM frequency will be calculated
    - False or None: no mean ELM frequency calculation
    - Two element numeric: mean ELM frequency will be calculated in this interval; can differ from time_range.

:param overlay: bool
    Overlay on existing figure instead of making a new one

:param fig: matplotlib Figure instance
    Figure to use when overlaying.

:param axs: List of at least two matplotlib Axes instances
    Axes to use when overlaying

:param quiet: bool
    Convert all print to printd

:param plotkw: Additional keywords are passed to pyplot.plot()

:return: (Figure instance, array of Axes instances)
"""
import matplotlib as mpl
from matplotlib import pyplot

def printq(*args):
    if quiet:
        printd(*args, topic='OMFITelm')
    else:
        print(*args)

# Make sure results are ready
if 'elm_freq' not in self:
    self.calc_frequency(plot_result=False)

# Figure setup
if overlay or fig:
    if fig is None:
        fig = pyplot.gcf()
    if axs is None:
        pyplot.figure(num=fig.number)
        ax0 = pyplot.subplot(211)
        ax1 = pyplot.subplot(212, sharex=ax0)
        axs = [ax0, ax1]
else:
    fig, axs = pyplot.subplots(2, sharex='col')

axs[0].set_ylabel(r'$D_{\alpha}$ (AU)')
axs[1].set_xlabel('Time (ms)')
axs[1].set_ylabel('ELM frequency (Hz)')
axs[1].set_title('Frequency calculation method {}'.format(self['elm_freq_method']))
axs[0].label_outer()
axs[0].xaxis.get_offset_text().set_visible(False)

# Data setup
which_fs = self['dalpha_filters']
x = self['dalpha_time']
y = self['dalpha_y']

xf = self['elm_freq_time']
f = self['elm_freq']

if time_range is None:
    # Pick time range
    tw = self['settings']['detection']['time_window']
    time_range = [max([tw[0], x.min()]), min([tw[1], x.max()])]
axs[1].set_xlim(time_range)

# Do plot
use_mf = time_range_for_mean is not None and time_range_for_mean is not False
axs[0].plot(x, y, **plotkw)
fllw = plotkw.pop('lw', mpl.rcParams['lines.linewidth'] * (0.5 if use_mf else 1))
fllw = plotkw.pop('linewidth', fllw)
freq_line = axs[1].plot(xf, f, zorder=0, lw=fllw, **plotkw)
axs[0].set_title('+'.join(tolist(which_fs)))

if use_mf:
    if time_range_for_mean is True:
        time_range_for_mean = time_range
    w = (x >= time_range_for_mean[0]) & (x <= time_range_for_mean[1])
    f1 = interp1d(xf, f, bounds_error=False, fill_value=np.NaN)(x)[w]
    mean_freq = np.nanmean(f1)
    std_freq = np.nanstd(f1)
    printq('Mean ELM frequency during interval {} ms = {:0.3f}+/-{:0.3f} Hz'.format(time_range_for_mean, mean_freq, std_freq))
    try:
        # Importing from omfit_classes.utils_plot has side effects that may be undesirable in command-line stand-alone testing
        contrast_color = contrasting_color(freq_line)
    except NameError:
        contrast_color = 'r'
    axs[1].errorbar(
        np.mean(time_range_for_mean),
        mean_freq,
        std_freq,
        np.std(time_range_for_mean),
        marker='d',
        ls=' ',
        zorder=2,
        lw=mpl.rcParams['lines.linewidth'] * 1.3 + 1.3,
        label=r'$\langle f_{{ELM}} \rangle$ = {:0.2f} Hz'.format(mean_freq),
        color=contrast_color,
    )
    axs[1].legend(loc=0, numpoints=1)

try:
    # Getting at OMFIT plot utilities when doing stand-alone command-line stuff can be a burden
    cornernote(shot=self.shot, device=self.device, time='')
except NameError:
    fig.text(0.99, 0.01, '{}#{}'.format(self.device, self.shot), fontsize=10, ha='right', transform=pyplot.gcf().transFigure)